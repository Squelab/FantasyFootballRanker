<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Draft Craft</title>
    <meta name="description" content="Free fantasy football draft tool and rankings builder. Create printable cheat sheets, drag and drop players, and win the draft. Works on mobile and desktop.">
    <meta name="keywords" content="fantasy football, draft tool, rankings builder, cheat sheet, fantasy draft, football rankings, draft helper, rankings tool">
    <meta property="og:title" content="Draft Craft - Fantasy Football Rankings Tool">
    <meta property="og:description" content="Free fantasy football draft tool and rankings builder. Create printable cheat sheets and win the draft.">
    <meta property="og:url" content="https://drftcrft.com">
    <meta property="og:type" content="website">
    <link rel="icon" href="favicon.ico?v=2" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico?v=2" type="image/x-icon">
    <link rel="icon" type="image/png" href="favicon.png?v=2">
    <link rel="apple-touch-icon" sizes="180x180" href="favicon.png?v=2">
    <link rel="apple-touch-icon" sizes="152x152" href="favicon.png?v=2">
    <link rel="apple-touch-icon" sizes="120x120" href="favicon.png?v=2">
    <link rel="apple-touch-icon" sizes="76x76" href="favicon.png?v=2">
    <link rel="apple-touch-icon" href="favicon.png?v=2">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon.png?v=2">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png?v=2">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon.png?v=2">
    <link rel="manifest" href="/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontSize: {
                        'mini': '0.675rem', // 90% of xs THESE ARE PERFECT SIZE
                        'mega': '1.0125rem', // 90% of lg THESE ARE PERFECT SIZE
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="styles.css">
</head>


<header class="bg-black border-b border-slate-700 sticky top-0 z-50">
    <div class="container mx-auto px-4 py-3 max-w-6xl">
        <div class="flex items-center justify-between">
            <!-- Left: Logo and Title -->
            <div class="flex items-center gap-3">
                <img src="favicon.png" alt="Draft Craft" class="w-10 h-10">
                <h1 id="dynamicTitle" class="text-2xl font-semibold text-gray-100">
                    Your 2025 PPR Rankings
                </h1>
            </div>

            <!-- Right: Hamburger Menu Button -->
            <div class="flex items-center">
                <button id="hamburgerMenuBtn" class="w-10 h-10 flex flex-col justify-center items-center space-y-1 text-gray-100 hover:text-white transition-colors">
                    <span class="block w-8 h-1.5 bg-current rounded-full transition-all duration-300"></span>
                    <span class="block w-8 h-1.5 bg-current rounded-full transition-all duration-300"></span>
                    <span class="block w-8 h-1.5 bg-current rounded-full transition-all duration-300"></span>
                </button>
            </div>
        </div>
    </div>

    <!-- Hamburger Menu (hidden by default) -->
    <div id="hamburgerMenu" class="hidden bg-slate-900 border-t border-slate-700">
        <div class="max-w-6xl mx-auto p-4">
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                <!-- Display Settings -->
                <div class="space-y-3">
                    <h3 class="text-gray-400 text-sm font-medium">Display Settings</h3>
                    <div class="space-y-3">
                        <!-- ADP Toggle -->
                        <div class="flex items-center justify-between">
                            <label for="adpToggle" class="text-white text-sm">Show ADP</label>
                            <button id="adpToggle" class="w-12 h-6 bg-blue-600 rounded-full relative transition-colors focus:outline-none">
                                <div class="w-5 h-5 bg-white rounded-full absolute top-0.5 right-0.5 transition-transform duration-200"></div>
                            </button>
                        </div>

                        <!-- Tiers Toggle -->
                        <div class="flex items-center justify-between">
                            <label for="tiersToggle" class="text-white text-sm">Show Tiers</label>
                            <button id="tiersToggle" class="w-12 h-6 bg-gray-600 rounded-full relative transition-colors focus:outline-none">
                                <div class="w-5 h-5 bg-white rounded-full absolute top-0.5 left-0.5 transition-transform duration-200"></div>
                            </button>
                        </div>

                        <!-- Risk Toggle -->
                        <div class="flex items-center justify-between">
                            <label for="riskToggle" class="text-white text-sm">Show Risk</label>
                            <button id="riskToggle" class="w-12 h-6 bg-blue-600 rounded-full relative transition-colors focus:outline-none">
                                <div class="w-5 h-5 bg-white rounded-full absolute top-0.5 right-0.5 transition-transform duration-200"></div>
                            </button>
                        </div>

                        <!-- Notes Toggle -->
                        <div class="flex items-center justify-between">
                            <label for="notesToggle" class="text-white text-sm">Show Notes</label>
                            <button id="notesToggle" class="w-12 h-6 bg-blue-600 rounded-full relative transition-colors focus:outline-none">
                                <div class="w-5 h-5 bg-white rounded-full absolute top-0.5 right-0.5 transition-transform duration-200"></div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tools -->
                <div class="space-y-3">
                    <h3 class="text-gray-400 text-sm font-medium">Tools</h3>
                    <div class="space-y-2">
                        <button id="draftBtnMenu" class="w-full bg-orange-600 border border-orange-500 text-white px-3 py-2 rounded-md hover:bg-orange-700 transition-all duration-200 text-sm">Draft Day</button>
                        <button id="printBtnMenu" class="w-full bg-purple-600 border border-purple-500 text-white px-3 py-2 rounded-md hover:bg-purple-700 transition-all duration-200 text-sm">Printable</button>
                        <button id="saveBtnMenu" class="w-full bg-green-600 border border-green-500 text-white px-3 py-2 rounded-md hover:bg-green-700 transition-all duration-200 text-sm">Save Rankings</button>
                        <label class="w-full bg-blue-600 border border-blue-500 text-white px-3 py-2 rounded-md hover:bg-blue-700 cursor-pointer transition-all duration-200 text-sm flex items-center justify-center">
                            Load Rankings
                            <input type="file" id="loadFileInputMenu" accept=".json" class="hidden">
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>



<body class="bg-slate-900 min-h-screen text-gray-100">
    <div id="deleteZone" class="w-10 h-10 bg-red-600 border-2 border-red-500 rounded-md flex items-center justify-center hover:bg-red-700 transition-all duration-200 cursor-pointer" title="Drop player here to delete">
        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
    </div>
    <div class="container mx-auto p-4 max-w-6xl">
        <!-- Header Controls -->
        <div class="bg-slate-800 rounded-lg shadow-xl p-4 mb-2 border border-slate-700">
            <div class="flex flex-col gap-4">
                <!-- Controls Grid - Mobile: 2x3, Desktop: 1x6 -->
                <div class="grid grid-cols-2 lg:grid-cols-6 gap-3">
                    <input type="text" id="rankerName" placeholder="Your Name" class="bg-slate-700 border border-slate-600 rounded-md px-3 py-2 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:outline-none h-10">

                    <select id="scoringFormat" class="bg-slate-700 border border-slate-600 rounded-md px-3 py-2 text-gray-100 focus:border-blue-500 focus:outline-none h-10">
                        <option value="PPR">PPR</option>
                        <option value="Half PPR">Half PPR</option>
                        <option value="Standard">Standard</option>
                    </select>

                    <label class="bg-blue-600 border-2 border-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-700 cursor-pointer transition-all duration-200 flex items-center justify-center text-center h-10 font-medium">
                        Load Rankings
                        <input type="file" id="loadFileInput" accept=".json" class="hidden">
                    </label>

                    <button id="saveBtn" class="bg-green-600 border-2 border-green-500 text-white px-4 py-2 rounded-md hover:bg-green-700 transition-all duration-200 h-10 flex items-center justify-center font-medium">Save Rankings</button>

                    <button id="draftBtn" class="bg-orange-600 border-2 border-orange-500 text-white px-4 py-2 rounded-md hover:bg-orange-700 transition-all duration-200 h-10 flex items-center justify-center font-medium">Draft Day</button>

                    <button id="printBtn" class="bg-purple-600 border-2 border-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-700 transition-all duration-200 h-10 flex items-center justify-center font-medium">Printable</button>
                </div>
            </div>
        </div>





        <!-- Search Section -->
        <div class="bg-slate-800 rounded-lg shadow-xl p-4 mb-2 border border-slate-700">
            <div class="flex gap-2">
                <div class="relative flex-grow">
                    <input type="text" id="searchInput" placeholder="Search players & teams..." class="h-10 w-full bg-slate-700 border border-slate-600 rounded-md px-3 py-2 pr-8 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:outline-none">
                    <button id="clearSearch" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-200 transition-colors" style="display: none;">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <button id="scoringFormatCycle" class="w-[18px] h-10 bg-slate-600 border-2 border-slate-500 rounded-md flex flex-col items-center justify-center hover:bg-slate-700 transition-all duration-200 cursor-pointer text-white font-medium relative overflow-hidden" title="Scoring Format: PPR">
                    <div class="absolute inset-0 bg-blue-500 opacity-30 transition-transform duration-200 ease-in-out" id="formatHighlight" style="transform: translateY(0); height: 33.33%;"></div>
                    <div class="relative z-10 flex-1 flex items-center justify-center" data-format="PPR">
                        <div class="w-2 h-2 bg-white rounded-full"></div>
                    </div>
                    <div class="relative z-10 flex-1 flex items-center justify-center" data-format="Half PPR">
                        <div class="w-2 h-2 rounded-full border border-white relative overflow-hidden">
                            <div class="absolute left-0 top-0 w-1 h-2 bg-white"></div>
                        </div>
                    </div>
                    <div class="relative z-10 flex-1 flex items-center justify-center" data-format="Standard">
                        <div class="w-2 h-2 border border-white rounded-full"></div>
                    </div>
                </button>
                <button id="positionFilter" class="w-10 h-10 bg-slate-600 border-2 border-slate-500 rounded-md flex items-center justify-center hover:opacity-80 transition-all duration-200 cursor-pointer text-white font-bold text-sm" title="Filter by position">
                    <img src="favicon.png" class="w-7 h-7">
                </button>
                <div class="flex flex-col gap-1">
                    <button id="undoBtn" class="w-10 h-[18px] bg-slate-600 border-2 border-slate-500 rounded-md flex items-center justify-center hover:bg-slate-700 transition-all duration-200 cursor-pointer text-white disabled:opacity-50 disabled:cursor-not-allowed" title="Undo (Ctrl+Z)" disabled>
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                        </svg>
                    </button>
                    <button id="redoBtn" class="w-10 h-[18px] bg-slate-600 border-2 border-slate-500 rounded-md flex items-center justify-center hover:bg-slate-700 transition-all duration-200 cursor-pointer text-white disabled:opacity-50 disabled:cursor-not-allowed" title="Redo (Ctrl+Y)" disabled>
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M21 10h-10a8 8 0 00-8 8v2m18-10l-6 6m6-6l-6-6"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>






        <!-- Rankings List -->
        <div class="bg-slate-800 rounded-lg shadow-xl p-4 border border-slate-700">
            <div id="playersList"></div>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notesModal" class="notes-modal hidden">
        <div class="notes-modal-content">
            <div class="notes-modal-header">
                <div id="notesModalTitle" class="notes-modal-title">Player - Notes</div>
                <button id="notesModalClose" class="notes-modal-close">×</button>
            </div>
            <div class="notes-modal-body">
                <textarea id="notesModalTextarea" class="notes-modal-textarea" placeholder="Add your notes about this player..."></textarea>
            </div>
        </div>
    </div>

    <script>
        // State management
        const state = {
            players: [],
            filteredPlayers: [],
            availablePlayers: [],
            draftedPlayers: [],
            isDraftMode: false,
            originalConsensus: {},
            consensusData: {},
            allConsensusData: {},
            currentFormat: 'PPR',
            positionFilter: 'ALL',
            history: {
                undoStack: [],
                redoStack: [],
                maxSize: 50
            },
            notesModal: {
                isOpen: false,
                currentPlayerId: null
            },
            dragState: {
                element: null,
                dragElement: null,
                index: -1,
                placeholder: null,
                isDragging: false,
                pendingDrag: false,
                startX: 0,
                startY: 0,
                originalRect: null,
                timers: { touch: null, resize: null, scroll: null },
                isScrolling: false,
                wasOverDelete: false,
                currentScrollSpeed: 0,
            }
        };

        // Hamburger setup
        function setupHamburgerMenu() {
            const menuBtn = $('hamburgerMenuBtn');
            const menu = $('hamburgerMenu');
            let isOpen = false;

            // Toggle menu
            on(menuBtn, 'click', () => {
                isOpen = !isOpen;
                menu.classList.toggle('hidden');

                // Hamburger to X animation
                const lines = menuBtn.querySelectorAll('span');
                if (isOpen) {
                    lines[0].style.transform = 'translateY(10px) rotate(45deg)';
                    lines[1].style.opacity = '0';
                    lines[1].style.transform = 'scale(0)';
                    lines[2].style.transform = 'translateY(-10px) rotate(-45deg)';
                } else {
                    lines[0].style.transform = 'translateY(0) rotate(0)';
                    lines[1].style.opacity = '1';
                    lines[1].style.transform = 'scale(1)';
                    lines[2].style.transform = 'translateY(0) rotate(0)';
                }
            });

            // Update the close handler
            on(document, 'click', (e) => {
                if (isOpen && !menuBtn.contains(e.target) && !menu.contains(e.target)) {
                    isOpen = false;
                    menu.classList.add('hidden');
                    const lines = menuBtn.querySelectorAll('span');
                    lines[0].style.transform = 'translateY(0) rotate(0)';
                    lines[1].style.opacity = '1';
                    lines[1].style.transform = 'scale(1)';
                    lines[2].style.transform = 'translateY(0) rotate(0)';
                }
            });

            // Close menu when clicking outside
            on(document, 'click', (e) => {
                if (isOpen && !menuBtn.contains(e.target) && !menu.contains(e.target)) {
                    isOpen = false;
                    menu.classList.add('hidden');
                    const lines = menuBtn.querySelectorAll('span');
                    lines[0].style.transform = '';
                    lines[1].style.opacity = '1';
                    lines[2].style.transform = '';
                }
            });

            setupToggleSwitches();
            updateNotesPositioning();

            on($('draftBtnMenu'), 'click', toggleDraftMode);
            on($('printBtnMenu'), 'click', downloadPrintable);
            on($('saveBtnMenu'), 'click', saveRankings);
            on($('loadFileInputMenu'), 'change', loadRankings);
        }

        // Toggle Switch Functionality
        function setupToggleSwitches() {
            // State for toggles (initially all enabled except Tiers)
            const toggleState = {
                adp: true,
                tiers: false,
                risk: true,
                notes: true
            };

            // Function to toggle a switch
            const toggleSwitch = (toggleId, stateKey) => {
                const toggle = $(toggleId);
                const circle = toggle.querySelector('div');

                on(toggle, 'click', () => {
                    toggleState[stateKey] = !toggleState[stateKey];

                    if (toggleState[stateKey]) {
                        toggle.classList.remove('bg-gray-600');
                        toggle.classList.add('bg-blue-600');
                        circle.classList.remove('left-0.5');
                        circle.classList.add('right-0.5');
                    } else {
                        toggle.classList.remove('bg-blue-600');
                        toggle.classList.add('bg-gray-600');
                        circle.classList.remove('right-0.5');
                        circle.classList.add('left-0.5');
                    }

                    applyDisplaySettings(stateKey, toggleState[stateKey]);
                });

                if (toggleState[stateKey]) {
                    toggle.classList.add('bg-blue-600');
                    circle.classList.add('right-0.5');
                }
            };

            toggleSwitch('adpToggle', 'adp');
            toggleSwitch('tiersToggle', 'tiers');
            toggleSwitch('riskToggle', 'risk');
            toggleSwitch('notesToggle', 'notes');
        }

        // Apply display settings
        function applyDisplaySettings(setting, enabled) {
            console.log(`${setting} ${enabled ? 'enabled' : 'disabled'}`);

            switch (setting) {
                case 'adp':
                    document.querySelectorAll('.adp').forEach(el => {
                        el.style.display = enabled ? 'inline' : 'none';
                    });
                    break;
                case 'risk':
                    document.querySelectorAll('button[onclick*="cycleRisk"]').forEach(el => {
                        el.style.display = enabled ? 'flex' : 'none';
                    });
                    // Update notes positioning when risk is toggled
                    updateNotesPositioning();
                    break;
                case 'notes':
                    document.querySelectorAll('.notes-section').forEach(el => {
                        el.style.display = enabled ? 'flex' : 'none';
                    });
                    document.querySelectorAll('.notes-icon').forEach(el => {
                        el.style.display = enabled ? 'flex' : 'none';
                    });
                    break;
                case 'tiers':
                    break;
            }
        }

        function updateNotesPositioning() {
            const riskButtons = document.querySelectorAll('button[onclick*="cycleRisk"]');
            const isRiskVisible = riskButtons.length > 0 && riskButtons[0].style.display !== 'none';

            // Update notes sections and icons positioning
            document.querySelectorAll('.notes-section, .notes-icon').forEach(el => {
                if (isRiskVisible) {
                    el.classList.remove('order-last');
                } else {
                    el.classList.add('order-last');
                }
            });
        }

        // Generate title for downloads & header (printable)
        function generateTitle() {
            const rankerName = $('rankerName').value.trim() || 'Your';
            const year = cfg.year;
            const format = document.getElementById('scoringFormatCycle')?.dataset.format || 'PPR';

            let titleName;
            if (rankerName.toLowerCase() === 'your') {
                titleName = rankerName; // "Your"
            } else if (rankerName.toLowerCase().endsWith('s')) {
                titleName = rankerName + "'"; // "James'"
            } else {
                titleName = rankerName + "'s"; // "John's"
            }

            return `${titleName} ${year} ${format} Rankings`;
        }

        function updateDynamicTitle() {
            const titleElement = $('dynamicTitle');
            if (titleElement) {
                titleElement.textContent = generateTitle();
            }
        }

        // Event listeners to update title when inputs change
        function setupTitleUpdates() {
            on($('rankerName'), 'input', updateDynamicTitle);
            on($('scoringFormat'), 'change', updateDynamicTitle);

            // Initial title update
            updateDynamicTitle();
        }

        // Haptic pickup/drop Idk if this works I only have an iphone
        const vibrate = (pattern) => {
            if (window.navigator.vibrate) {
                window.navigator.vibrate(pattern);
            }
        };

        // Scoring format cycle
        const scoringFormats = ['PPR', 'Half PPR', 'Standard'];

        // Create delete overlay
        const deleteOverlay = document.createElement('div');
        deleteOverlay.className = 'delete-overlay';
        document.body.appendChild(deleteOverlay);

        // Configuration
        const cfg = {
            year: new Date().getFullYear(),
            risks: ['Low', 'Medium', 'High'],
            formats: ['PPR', 'Half PPR', 'Standard'],
            fileMap: { 'PPR': 'PPR.json', 'Half PPR': 'HPPR.json', 'Standard': 'STAN.json' },
            skillPositions: ['RB', 'WR', 'TE', 'QB'],
            positionFilters: ['ALL', 'RB', 'WR', 'TE', 'QB'],
            maxPlayers: 200,
            recentDraftedCount: 3,
            dragThreshold: 15,
            dragDelay: 130,
            styles: {
                riskBtn: { High: 'bg-red-600', Medium: 'bg-yellow-600', Low: 'bg-green-600' },
                riskBorder: { High: 'border-red-500', Medium: 'border-yellow-500', Low: 'border-green-500' },
                posColors: {
                    QB: 'bg-purple-900/50 border-l-4 border-purple-600',
                    RB: 'bg-blue-900/50 border-l-4 border-blue-600',
                    WR: 'bg-green-900/50 border-l-4 border-green-600',
                    TE: 'bg-orange-900/50 border-l-4 border-orange-600',
                    K: 'bg-pink-900/50 border-l-4 border-pink-600',
                    DST: 'bg-gray-700/50 border-l-4 border-gray-600'
                },
                positionBadge: {
                    QB: 'text-purple-300 bg-purple-900/50',
                    RB: 'text-blue-300 bg-blue-900/50',
                    WR: 'text-green-300 bg-green-900/50',
                    TE: 'text-orange-300 bg-orange-900/50',
                    K: 'text-pink-300 bg-pink-900/50',
                    DST: 'text-gray-300 bg-gray-700/50'
                },
                positionFilterColors: {
                    'ALL': 'bg-slate-600 border-slate-500',
                    'QB': 'bg-purple-600 border-purple-500',
                    'RB': 'bg-blue-600 border-blue-500',
                    'WR': 'bg-green-600 border-green-500',
                    'TE': 'bg-orange-600 border-orange-500'
                }
            }
        };

        // Utilities
        const $ = id => document.getElementById(id);
        const on = (el, evt, fn, opts) => el.addEventListener(evt, fn, opts);
        const debounce = (fn, ms) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); } };
        const deepCopy = obj => JSON.parse(JSON.stringify(obj));

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Set up event listeners using map for cleaner code
            const eventMap = {
                searchInput: ['input', debounce(filterPlayers, 150)],
                loadFileInput: ['change', loadRankings],
                saveBtn: ['click', saveRankings],
                printBtn: ['click', downloadPrintable],
                draftBtn: ['click', toggleDraftMode],
                notesModalClose: ['click', closeNotesModal],
                searchInput: ['input', handleSearchInput],
                clearSearch: ['click', handleClearSearch],
                positionFilter: ['click', cyclePositionFilter],
                undoBtn: ['click', undo],
                redoBtn: ['click', redo],
                rankerName: ['input', updateDynamicTitle],
                scoringFormatCycle: ['click', cycleScoringFormat],
            };

            Object.entries(eventMap).forEach(([id, [event, handler]]) => {
                on($(id), event, handler);
            });

            setupHamburgerMenu();

            // Modal background click to close
            on($('notesModal'), 'click', (e) => {
                if (e.target === $('notesModal')) {
                    closeNotesModal();
                }
            });

            // Keyboard shortcuts
            on(document, 'keydown', (e) => {
                // Escape key to close modal
                if (e.key === 'Escape' && state.notesModal.isOpen) {
                    closeNotesModal();
                    return;
                }

                // Undo/Redo shortcuts (but not when typing in inputs)
                if (!['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    if (e.ctrlKey || e.metaKey) {
                        // Shift+Z (Redo) - just Z (Undo) - Ctrl+Y (alternative redo)
                        if (e.key === 'Z' && e.shiftKey) {
                            e.preventDefault();
                            redo();
                        }
                        else if (e.key === 'z' && !e.shiftKey) {
                            e.preventDefault();
                            undo();
                        }
                        else if (e.key === 'y') {
                            e.preventDefault();
                            redo();
                            console.log('Redo (Ctrl+Y) triggered'); // Debug log
                        }
                    }
                }
            });

            // Reset scroll state when touches are cancelled/interrupted
            document.addEventListener('touchcancel', () => {
                if (state.dragState.isScrolling) {
                    state.dragState.isScrolling = false;
                    if (state.dragState.timers.scroll) {
                        cancelAnimationFrame(state.dragState.timers.scroll);
                    }
                }
            });

            // Reset scroll state when page loses focus
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && state.dragState.isScrolling) {
                    state.dragState.isScrolling = false;
                    if (state.dragState.timers.scroll) {
                        cancelAnimationFrame(state.dragState.timers.scroll);
                    }
                }
            });

            on(window, 'resize', () => {
                cancelDragOperation();
                clearTimeout(state.dragState.timers.resize);
                state.dragState.timers.resize = setTimeout(filterPlayers, 250);
            });

            // Warn before page refresh/close
            on(window, 'beforeunload', (e) => {
                e.preventDefault();
                e.returnValue = 'Are you sure you want to leave? You will lose your unsaved rankings progress.';
                return 'Are you sure you want to leave? You will lose your unsaved rankings progress.';
            });

            loadAllScoringFormats();
        });

        function handleSearchInput() {
            const clearBtn = $('clearSearch');
            const searchValue = $('searchInput').value;

            if (searchValue.length > 0) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }

            filterPlayers();
        }

        function handleClearSearch() {
            const searchInput = $('searchInput');
            searchInput.value = '';
            $('clearSearch').style.display = 'none';
            searchInput.focus();
            filterPlayers();
        }

        // History management for undo/redo
        function saveState(action = 'action') {
            // Clear redo stack when new action is performed
            state.history.redoStack = [];

            // Save current state to undo stack
            const snapshot = {
                players: deepCopy(state.players),
                draftedPlayers: deepCopy(state.draftedPlayers),
                action: action,
                timestamp: Date.now()
            };

            state.history.undoStack.push(snapshot);

            // Limit undo stack size
            if (state.history.undoStack.length > state.history.maxSize) {
                state.history.undoStack.shift();
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (state.history.undoStack.length === 0) return;

            // Save current state to redo stack
            const currentSnapshot = {
                players: deepCopy(state.players),
                draftedPlayers: deepCopy(state.draftedPlayers),
                action: 'current',
                timestamp: Date.now()
            };
            state.history.redoStack.push(currentSnapshot);

            // Restore previous state
            const previousSnapshot = state.history.undoStack.pop();
            state.players = previousSnapshot.players;
            state.draftedPlayers = previousSnapshot.draftedPlayers;

            recalculateRanks();
            filterPlayers();
            if (state.isDraftMode) renderRecentlyDrafted();
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.history.redoStack.length === 0) return;

            // Save current state to undo stack
            const currentSnapshot = {
                players: deepCopy(state.players),
                draftedPlayers: deepCopy(state.draftedPlayers),
                action: 'undo',
                timestamp: Date.now()
            };
            state.history.undoStack.push(currentSnapshot);

            // Restore next state
            const nextSnapshot = state.history.redoStack.pop();
            state.players = nextSnapshot.players;
            state.draftedPlayers = nextSnapshot.draftedPlayers;

            recalculateRanks();
            filterPlayers();
            if (state.isDraftMode) renderRecentlyDrafted();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = $('undoBtn');
            const redoBtn = $('redoBtn');

            undoBtn.disabled = state.history.undoStack.length === 0;
            redoBtn.disabled = state.history.redoStack.length === 0;
        }

        // Notes Modal Functions
        function openNotesModal(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (!player) return;

            state.notesModal.isOpen = true;
            state.notesModal.currentPlayerId = playerId;

            $('notesModalTitle').textContent = `${player.name} - Notes`;
            $('notesModalTextarea').value = player.notes || '';
            $('notesModal').classList.remove('hidden');

            setTimeout(() => {
                $('notesModalTextarea').focus();
            }, 100);
        }

        function closeNotesModal() {
            if (!state.notesModal.isOpen) return;

            const notes = $('notesModalTextarea').value;
            if (state.notesModal.currentPlayerId) {
                updateNotes(state.notesModal.currentPlayerId, notes);
            }

            state.notesModal.isOpen = false;
            state.notesModal.currentPlayerId = null;
            $('notesModal').classList.add('hidden');
        }

        // Position filter functionality
        function cyclePositionFilter() {
            const currentIndex = cfg.positionFilters.indexOf(state.positionFilter);
            const nextIndex = (currentIndex + 1) % cfg.positionFilters.length;
            state.positionFilter = cfg.positionFilters[nextIndex];

            updatePositionFilterButton();
            filterPlayers();
        }

        function updatePositionFilterButton() {
            const btn = $('positionFilter');
            const colors = cfg.styles.positionFilterColors[state.positionFilter];

            btn.className = `w-10 h-10 ${colors} border-2 rounded-md flex items-center justify-center hover:opacity-80 transition-all duration-200 cursor-pointer text-white font-bold text-sm`;

            if (state.positionFilter === 'ALL') {
                btn.innerHTML = '<img src="favicon.png" class="w-7 h-7">';
            } else {
                btn.innerHTML = state.positionFilter;
            }

            btn.title = `Filter by position (${state.positionFilter})`;
        }

        // Data loading
        async function loadAllScoringFormats() {
            try {
                await Promise.all(cfg.formats.map(async format => {
                    const response = await fetch(`./data/${cfg.fileMap[format]}`);
                    if (response.ok) {
                        const data = await response.json();
                        const allPlayers = data.players || data;

                        // Store ALL players for search functionality
                        state.allConsensusData[format] = allPlayers.map((p, i) => ({
                            ...p,
                            id: p.id || `p${i}`,
                            risk: p.risk || 'Medium',
                            notes: p.notes || '',
                            originalRank: i + 1
                        }));

                        // Store filtered skill players for initial load
                        const skillPlayers = allPlayers
                            .filter(p => cfg.skillPositions.includes(p.position))
                            .slice(0, cfg.maxPlayers);

                        state.consensusData[format] = skillPlayers.map((p, i) => ({
                            ...p,
                            id: p.id || `p${i}`,
                            risk: p.risk || 'Medium',
                            notes: p.notes || '',
                            overallRank: i + 1
                        }));
                    }
                }));

                state.currentFormat = 'PPR';
                updateScoringButton('PPR');

                loadPlayersFromConsensus(state.currentFormat);
            } catch (error) {
                console.error('Error loading scoring formats:', error);
                loadPlayersFromFile();
            }
        }

        function loadPlayersFromConsensus(format) {
            if (!state.consensusData[format]) return;

            state.players = deepCopy(state.consensusData[format]);
            recalculateRanks();
            state.originalConsensus[format] = deepCopy(state.players);
            // Clear history when loading fresh data
            state.history.undoStack = [];
            state.history.redoStack = [];
            updateUndoRedoButtons();
            filterPlayers();
        }

        function loadPlayersFromFile() {
            const format = $('scoringFormat').value || 'PPR';
            const filename = cfg.fileMap[format] || 'PPR.json';

            fetch(`./data/${filename}`)
                .then(r => r.ok ? r.json() : Promise.reject())
                .then(d => {
                    const allPlayers = d.players || d;

                    // Store ALL players
                    state.allConsensusData[format] = allPlayers.map((p, i) => ({
                        ...p,
                        id: p.id || `p${i}`,
                        risk: p.risk || 'Medium',
                        notes: p.notes || '',
                        originalRank: i + 1
                    }));

                    const skillPlayers = allPlayers
                        .filter(p => cfg.skillPositions.includes(p.position))
                        .slice(0, cfg.maxPlayers);

                    state.players = skillPlayers.map((p, i) => ({
                        ...p,
                        id: p.id || `p${i}`,
                        risk: p.risk || 'Medium',
                        notes: p.notes || '',
                        overallRank: i + 1
                    }));

                    recalculateRanks();
                    state.originalConsensus[format] = deepCopy(state.players);
                    filterPlayers();
                });
        }

        function cycleScoringFormat() {
            const button = document.getElementById('scoringFormatCycle');
            const currentFormat = button.dataset.format || 'PPR';
            const currentIndex = scoringFormats.indexOf(currentFormat);
            const nextIndex = (currentIndex + 1) % scoringFormats.length;
            const newFormat = scoringFormats[nextIndex];

            // Update button visual and data
            updateScoringButton(newFormat);

            // Use existing logic
            const previousFormat = state.currentFormat;
            state.currentFormat = newFormat;

            if (isUnedited(previousFormat)) {
                loadPlayersFromConsensus(newFormat);
            } else {
                updateADPValues(newFormat);
            }

            updateDynamicTitle();
        }

        function updateScoringButton(format) {
            const button = document.getElementById('scoringFormatCycle');
            const highlight = document.getElementById('formatHighlight');
            button.dataset.format = format;
            button.title = `Scoring Format: ${format}`;

            // Move highlight based on format
            const positions = {
                'PPR': 'translateY(0)',           // top third
                'Half PPR': 'translateY(100%)',   // middle third  
                'Standard': 'translateY(200%)'    // bottom third
            };

            highlight.style.transform = positions[format];
        }

        function isUnedited(formatToCheck = null) {
            const checkFormat = formatToCheck || state.currentFormat;
            const original = state.originalConsensus[checkFormat];

            if (!original || state.players.length !== original.length) return false;

            return state.players.every((p, i) => {
                const orig = original[i];
                return Object.keys(p).every(key => p[key] === orig[key]);
            });
        }

        function updateADPValues(format) {
            if (!state.consensusData[format]) return;

            const adpMap = new Map(
                state.consensusData[format].map(p => [`${p.name}-${p.team}`, p.adp])
            );

            state.players.forEach(player => {
                const adp = adpMap.get(`${player.name}-${player.team}`);
                if (adp !== undefined) player.adp = adp;
            });

            filterPlayers();
        }

        // Player management
        function recalculateRanks() {
            const posCounts = {};
            state.players.forEach((p, i) => {
                posCounts[p.position] = (posCounts[p.position] || 0) + 1;
                p.overallRank = i + 1;
                p.positionRank = posCounts[p.position];
            });
        }

        function filterPlayers() {
            const search = $('searchInput').value.toLowerCase();

            if (state.positionFilter === 'ALL') {
                state.filteredPlayers = state.players.filter(p =>
                    advancedPlayerSearch(p, search)
                );

                // Find available players to add (from all consensus data)
                state.availablePlayers = [];
                if (search.length >= 2 && state.allConsensusData[state.currentFormat]) {
                    const currentPlayerIds = new Set(state.players.map(p => p.id));

                    state.availablePlayers = state.allConsensusData[state.currentFormat]
                        .filter(p =>
                            !currentPlayerIds.has(p.id) &&
                            advancedPlayerSearch(p, search)
                        )
                        .slice(0, 10);
                }
            } else {
                // Show only selected position from current rankings
                state.filteredPlayers = state.players.filter(p =>
                    p.position === state.positionFilter &&
                    advancedPlayerSearch(p, search)
                );

                // Show available players of this position (not in current rankings)
                const currentPlayerIds = new Set(state.players.map(p => p.id));
                state.availablePlayers = [];

                if (state.allConsensusData[state.currentFormat]) {
                    state.availablePlayers = state.allConsensusData[state.currentFormat]
                        .filter(p =>
                            p.position === state.positionFilter &&
                            !currentPlayerIds.has(p.id) &&
                            (search.length === 0 || advancedPlayerSearch(p, search))
                        )
                        .slice(0, 20);
                }
            }

            renderPlayers();
        }

        function advancedPlayerSearch(player, searchTerm) {
            if (!searchTerm) return true;

            // Normalize function to handle punctuation and case
            const normalize = (str) => {
                return str.toLowerCase()
                    .replace(/[''`]/g, "'")
                    .replace(/[^\w\s']/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            };

            // Team name mappings for common abbreviations
            const teamMappings = {
                'arizona': ['ari', 'cardinals', 'arizona'],
                'atlanta': ['atl', 'falcons', 'atlanta'],
                'baltimore': ['bal', 'ravens', 'baltimore'],
                'buffalo': ['buf', 'bills', 'buffalo'],
                'carolina': ['car', 'panthers', 'carolina'],
                'chicago': ['chi', 'bears', 'chicago'],
                'cincinnati': ['cin', 'bengals', 'cincinnati'],
                'cleveland': ['cle', 'browns', 'cleveland'],
                'dallas': ['dal', 'cowboys', 'dallas'],
                'denver': ['den', 'broncos', 'denver'],
                'detroit': ['det', 'lions', 'detroit'],
                'green bay': ['gb', 'packers', 'green bay'],
                'houston': ['hou', 'texans', 'houston'],
                'indianapolis': ['ind', 'colts', 'indianapolis'],
                'jacksonville': ['jax', 'jaguars', 'jacksonville'],
                'kansas city': ['kc', 'chiefs', 'kansas city'],
                'las vegas': ['lv', 'raiders', 'las vegas'],
                'los angeles chargers': ['lac', 'chargers', 'los angeles chargers'],
                'los angeles rams': ['lar', 'rams', 'los angeles rams'],
                'miami': ['mia', 'dolphins', 'miami'],
                'minnesota': ['min', 'vikings', 'minnesota'],
                'new england': ['ne', 'patriots', 'new england'],
                'new orleans': ['no', 'saints', 'new orleans'],
                'new york giants': ['nyg', 'giants', 'new york giants'],
                'new york jets': ['nyj', 'jets', 'new york jets'],
                'philadelphia': ['phi', 'eagles', 'philadelphia'],
                'pittsburgh': ['pit', 'steelers', 'pittsburgh'],
                'san francisco': ['sf', '49ers', 'niners', 'san francisco'],
                'seattle': ['sea', 'seahawks', 'seattle'],
                'tampa bay': ['tb', 'buccaneers', 'bucs', 'tampa bay'],
                'tennessee': ['ten', 'titans', 'tennessee'],
                'washington': ['was', 'commanders', 'washington']
            };

            const normalizedSearch = normalize(searchTerm);
            const normalizedName = normalize(player.name);
            const normalizedTeam = normalize(player.team);

            // Create expanded team search terms
            let teamSearchTerms = [normalizedTeam, player.team.toLowerCase()];

            // Add team mappings
            Object.values(teamMappings).forEach(aliases => {
                if (aliases.some(alias => alias === normalizedTeam || alias === player.team.toLowerCase())) {
                    teamSearchTerms.push(...aliases);
                }
            });

            // For name matching, try different approaches
            const nameMatches = (searchWord) => {
                // Direct substring match
                if (normalizedName.includes(searchWord)) return true;

                // Check if search word matches start of any name part
                const nameParts = normalizedName.split(' ');
                if (nameParts.some(part => part.startsWith(searchWord))) return true;

                // This handles cases like "jam" -> "ja'm" to match "ja'marr"
                for (let i = 1; i < searchWord.length; i++) {
                    const withApostrophe = searchWord.slice(0, i) + "'" + searchWord.slice(i);
                    if (normalizedName.includes(withApostrophe)) return true;

                    // Also check if it matches start of name parts
                    if (nameParts.some(part => part.startsWith(withApostrophe))) return true;
                }

                return false;
            };

            const teamMatches = (searchWord) => {
                return teamSearchTerms.some(term =>
                    term.includes(searchWord) || term.startsWith(searchWord)
                );
            };

            // Split search into words for multi-word matching
            const searchWords = normalizedSearch.split(' ').filter(word => word.length > 0);

            // Check if all search words match somewhere in name or team
            return searchWords.every(word => {
                return nameMatches(word) || teamMatches(word);
            });
        }

        function addPlayer(playerId) {
            saveState('add player');
            const playerToAdd = state.allConsensusData[state.currentFormat]?.find(p => p.id === playerId);
            if (!playerToAdd) return;

            // Create new player object with current rankings properties
            const newPlayer = {
                ...playerToAdd,
                overallRank: state.players.length + 1,
                positionRank: 1
            };

            // Add to the end of rankings
            state.players.push(newPlayer);
            recalculateRanks();
            filterPlayers();
        }

        function updatePlayerOrder() {
            document.querySelectorAll('.drag-placeholder').forEach(el => el.remove());

            if (state.positionFilter === 'ALL') {
                // Normal behavior for all positions
                const playerElements = Array.from(document.querySelectorAll('.player-item:not(.drag-placeholder):not(.available-player)'));
                const newOrder = playerElements
                    .map(el => state.players.find(p => p.id === el.dataset.playerId))
                    .filter(Boolean);

                if (newOrder.length === state.players.length) {
                    // CHECK IF ORDER ACTUALLY CHANGED BEFORE SAVING STATE
                    const orderChanged = !state.players.every((player, index) =>
                        player.id === newOrder[index].id
                    );

                    if (orderChanged) {
                        saveState('reorder players');
                        state.players = newOrder;
                        recalculateRanks();
                        filterPlayers();
                    }
                } else {
                    console.error('Player count mismatch:', newOrder.length, 'vs', state.players.length);
                    filterPlayers();
                }
            } else {
                // Positional filtering logic
                const playerElements = Array.from(document.querySelectorAll('.player-item:not(.drag-placeholder):not(.available-player)'));
                const newPositionalOrder = playerElements
                    .map(el => state.players.find(p => p.id === el.dataset.playerId))
                    .filter(Boolean);

                // Get players not in the current position filter
                const otherPositionPlayers = state.players.filter(p => p.position !== state.positionFilter);

                // Rebuild the full rankings by interleaving the reordered position players
                const newFullRankings = [];
                let posIndex = 0;

                for (let i = 0; i < state.players.length; i++) {
                    const originalPlayer = state.players[i];

                    if (originalPlayer.position === state.positionFilter) {
                        if (posIndex < newPositionalOrder.length) {
                            newFullRankings.push(newPositionalOrder[posIndex]);
                            posIndex++;
                        }
                    } else {
                        newFullRankings.push(originalPlayer);
                    }
                }

                // CHECK IF ORDER ACTUALLY CHANGED BEFORE SAVING STATE
                const orderChanged = !state.players.every((player, index) =>
                    player.id === newFullRankings[index].id
                );

                if (orderChanged) {
                    saveState('reorder players');
                    // Update the master rankings
                    state.players = newFullRankings;
                    recalculateRanks();
                    filterPlayers();
                }
            }
        }

        // Rendering helpers
        const createRiskDraftButton = (action, player, isDraft) => {
            if (isDraft) {
                return `<button onclick="draftPlayer('${player.id}')" class="bg-red-600 border-2 border-red-500 w-10 h-10 rounded text-mini font-bold text-white hover:bg-red-700 transition-all duration-200 flex items-center justify-center">D</button>`;
            }
            return `<button onclick="cycleRisk('${player.id}')" class="${cfg.styles.riskBtn[player.risk]} border-2 ${cfg.styles.riskBorder[player.risk]} w-10 h-10 rounded text-mini font-bold text-white transition-all duration-200 flex items-center justify-center">${player.risk[0]}</button>`;
        };

        const createNotesIcon = (player, isDraft) => {
            if (isDraft) return '';
            return `<button onclick="openNotesModal('${player.id}')" class="notes-icon bg-slate-600 border-2 border-slate-500 w-10 h-10 rounded text-white hover:bg-slate-700 transition-all duration-200 flex items-center justify-center" title="Edit notes">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                    </svg>
                </button>`;
        };

        const createAddButton = (player) => {
            return `<button onclick="addPlayer('${player.id}')" class="bg-green-600 border-2 border-green-500 w-10 h-10 rounded text-white hover:bg-green-700 transition-all duration-200 flex items-center justify-center">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"></path>
                    </svg>
                </button>`;
        };

        const createNotes = (player, isDraft) => {
            if (isDraft) {
                return `<div class="w-full border border-slate-600 rounded px-2 py-1 text-sm h-10 bg-slate-700 text-gray-300">${player.notes || ''}</div>`;
            }
            return `<textarea placeholder="Add player notes..." onchange="updateNotes('${player.id}', this.value)" maxlength="165" class="w-full bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs resize-none h-10 text-gray-100 placeholder-gray-400 focus:border-blue-500 focus:outline-none">${player.notes}</textarea>`;
        };

        // Rendering
        function renderPlayers() {
            const container = $('playersList');
            const search = $('searchInput').value.toLowerCase();
            const isDraft = state.isDraftMode;

            const html = [];

            // Current players
            state.filteredPlayers.forEach((p, i) => {
                html.push(`
                        <div class="player-item ${cfg.styles.posColors[p.position]} hover:shadow-lg" data-player-id="${p.id}" data-index="${i}">
                            <div class="p-2 flex items-stretch gap-2">
                                <div class="drag-area flex items-stretch gap-2 flex-grow ${!isDraft ? 'cursor-move' : ''} lg:items-center lg:gap-1">
                                    <div class="w-12 flex flex-col items-center justify-center lg:text-center">
                                        <div class="text-mega font-bold text-gray-100 lg:text-2xl">${p.overallRank}</div>
                                        <div class="text-mini ${cfg.styles.positionBadge[p.position].split(' ')[0]} lg:hidden">${p.position}${p.positionRank}</div>
                                    </div>
                                    <span class="${cfg.styles.positionBadge[p.position]} px-2 py-1 rounded text-sm font-medium hidden lg:inline">${p.position}${p.positionRank}</span>
                                    <div class="px-2 flex-grow flex items-center">
                                        <div class="flex-grow">
                                            <div class="font-semibold text-mega text-gray-100">${p.name}</div>
                                            <div class="text-mini text-gray-400">
                                                <span>${p.team}</span>
                                                ${p.adp ? `<span class="ml-4 text-gray-400">ADP: ${p.adp}</span>` : ''}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="notes-section px-2 flex-shrink items-center overflow-hidden hidden lg:flex">${createNotes(p, isDraft)}</div>
                                <div class="w-10 flex items-center lg:hidden ${isRiskVisible ? '' : 'order-last'}">${createNotesIcon(p, isDraft)}</div>
                                <div class="w-10 flex items-center">${createRiskDraftButton('action', p, isDraft)}</div>
                            </div>
                        </div>
                    `);
            });

            // Available players
            state.availablePlayers.forEach((p, i) => {
                html.push(`
                        <div class="player-item available-player ${cfg.styles.posColors[p.position]} opacity-70 hover:shadow-lg" data-player-id="${p.id}" data-index="${i}">
                            <div class="p-2 flex items-stretch gap-2">
                                <div class="drag-area flex items-stretch gap-2 flex-grow ${!isDraft ? 'cursor-move' : ''} lg:items-center lg:gap-1">
                                    <div class="w-12 flex flex-col items-center justify-center lg:text-center">
                                        <div class="text-mega font-bold text-gray-100 lg:text-2xl">${p.originalRank || '-'}</div>
                                        <div class="text-mini ${cfg.styles.positionBadge[p.position].split(' ')[0]} lg:hidden">${p.position}${p.positionRank}</div>
                                    </div>
                                    <span class="${cfg.styles.positionBadge[p.position]} px-2 py-1 rounded text-sm font-medium hidden lg:inline">${p.position}${p.positionRank || ''}</span>
                                    <div class="px-2 flex-grow flex items-center">
                                        <div class="flex-grow">
                                            <div class="font-semibold text-mega text-gray-100">${p.name}</div>
                                            <div class="text-mini text-gray-400">
                                                <span>${p.team}</span>
                                                ${p.adp ? `<span class="ml-4 text-gray-400">ADP: ${p.adp}</span>` : ''}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="w-10 flex items-center">${createAddButton(p)}</div>
                            </div>
                        </div>
                    `);
            });

            container.innerHTML = html.join('');

            if (!isDraft) setupDragHandlers();
        }

        function renderRecentlyDrafted() {
            $('recentlyDraftedList').innerHTML = state.draftedPlayers.slice(0, cfg.recentDraftedCount).map(p => `
                    <div class="bg-slate-900 border border-slate-700 rounded-lg p-2 cursor-pointer hover:bg-slate-800 transition-colors">
                        <div class="flex items-center gap-2">
                            <span class="${cfg.styles.positionBadge[p.position]} px-2 py-1 rounded text-mini font-medium">${p.position}</span>
                            <div class="flex-grow">
                                <span class="font-semibold text-gray-100">${p.name}</span>
                                <span class="text-mini text-gray-400 ml-2">${p.team}</span>
                            </div>
                            <button onclick="undraftPlayer('${p.id}')" class="bg-blue-600 border-2 border-blue-500 text-white px-2 py-1 rounded text-mini hover:bg-blue-700 transition-all duration-200 font-medium">UNDO</button>
                        </div>
                    </div>
                `).join('');
        }

        // Drag and drop handling
        function setupDragHandlers() {
            document.querySelectorAll('.drag-area').forEach(item => {
                on(item, 'touchstart', handleTouchStart, { passive: true });
                on(item, 'touchmove', handleTouchMove, { passive: false });
                on(item, 'touchend', handleTouchEnd, { passive: true });
                on(item, 'mousedown', handleMouseDown);
            });
        }

        function initDrag(element, clientX, clientY) {
            // PREVENT DRAG IF ALREADY SCROLLING
            if (state.dragState.isScrolling) {
                console.log('Blocked drag - scroll in progress');
                return;
            }

            const rect = element.getBoundingClientRect();
            Object.assign(state.dragState, {
                element,
                index: parseInt(element.dataset.index),
                isDragging: true,
                startX: clientX,
                startY: clientY,
                originalRect: { left: rect.left, top: rect.top },
            });

            startAutoScroll();

            vibrate(50);

            state.dragState.placeholder = element.cloneNode(true);
            state.dragState.placeholder.classList.add('drag-placeholder');

            // Replace the risk button with delete button in placeholder
            const placeholderRiskBtn = state.dragState.placeholder.querySelector('button[onclick*="cycleRisk"]');
            if (placeholderRiskBtn) {
                const playerId = element.dataset.playerId;
                placeholderRiskBtn.outerHTML = `
                        <button onclick="deletePlayer('${playerId}')" class="delete-button bg-red-600 border-2 border-red-500 w-10 h-10 rounded text-white hover:bg-red-700 transition-all duration-200 flex items-center justify-center">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                        </button>
                    `;
            }

            // Make sure parent exists before inserting placeholder
            if (!element.parentNode) {
                console.warn('Element has no parent - aborting drag');
                state.dragState.isDragging = false;
                return;
            }

            // Insert placeholder
            try {
                element.parentNode.insertBefore(state.dragState.placeholder, element);
            } catch (e) {
                console.warn('Failed to insert placeholder:', e);
                state.dragState.isDragging = false;
                return;
            }

            element.classList.add('drag-active');
            Object.assign(element.style, {
                width: rect.width + 'px',
                height: rect.height + 'px',
                left: rect.left + 'px',
                top: rect.top + 'px'
            });
        }

        function moveDrag(clientX, clientY) {
            if (!state.dragState.isDragging || !state.dragState.element) return;

            const { element, startX, startY, originalRect, placeholder } = state.dragState;
            element.style.left = (originalRect.left + clientX - startX) + 'px';
            element.style.top = (originalRect.top + clientY - startY) + 'px';

            // Auto-scroll logic
            handleAutoScroll(clientY);

            // Check if over delete zone OR placeholder delete button
            const deleteZone = $('deleteZone');
            const deleteRect = deleteZone.getBoundingClientRect();
            const placeholderDeleteBtn = document.querySelector('.drag-placeholder .delete-button');
            let isOverDelete = clientX >= deleteRect.left && clientX <= deleteRect.right &&
                clientY >= deleteRect.top && clientY <= deleteRect.bottom;

            // Also check placeholder delete button
            if (!isOverDelete && placeholderDeleteBtn) {
                const btnRect = placeholderDeleteBtn.getBoundingClientRect();
                isOverDelete = clientX >= btnRect.left && clientX <= btnRect.right &&
                    clientY >= btnRect.top && clientY <= btnRect.bottom;
            }

            if (isOverDelete) {
                // Add red glow to entire page background
                deleteOverlay.classList.add('active');
                document.body.classList.add('delete-mode');

                deleteZone.classList.add('bg-red-800', 'scale-110');
                deleteZone.classList.remove('bg-red-600');
                state.dragState.wasOverDelete = true;
                return;
            } else {
                // Remove red glow from page background
                deleteOverlay.classList.remove('active');
                document.body.classList.remove('delete-mode');

                deleteZone.classList.remove('bg-red-800', 'scale-110');
                deleteZone.classList.add('bg-red-600');
                state.dragState.wasOverDelete = false;
            }

            element.style.pointerEvents = 'none';
            const elementBelow = document.elementFromPoint(clientX, clientY);
            element.style.pointerEvents = 'auto';

            const targetItem = elementBelow?.closest('.player-item');
            if (targetItem && placeholder && !targetItem.classList.contains('drag-active') && !targetItem.classList.contains('available-player')) {
                const targetRect = targetItem.getBoundingClientRect();
                const before = clientY < targetRect.top + targetRect.height / 2;
                targetItem.parentNode.insertBefore(placeholder, before ? targetItem : targetItem.nextSibling);
            }
        }

        function handleAutoScroll(clientY) {
            const viewportHeight = window.innerHeight;
            const isMobile = window.innerWidth < 768;

            // Define scroll zones
            const fastZone = isMobile ? 30 : 40;
            const mediumZone = isMobile ? 60 : 80;
            const slowZone = isMobile ? 90 : 120;

            let scrollSpeed = 0;

            // TOP ZONES
            if (clientY < fastZone) {
                scrollSpeed = -12;
            } else if (clientY < mediumZone) {
                scrollSpeed = -6;
            } else if (clientY < slowZone) {
                scrollSpeed = -3;
            }
            // BOTTOM ZONES
            else if (clientY > viewportHeight - fastZone) {
                scrollSpeed = 12;
            } else if (clientY > viewportHeight - mediumZone) {
                scrollSpeed = 6;
            } else if (clientY > viewportHeight - slowZone) {
                scrollSpeed = 3;
            }

            // Update scroll speed (don't call this function recursively!)
            state.dragState.currentScrollSpeed = scrollSpeed;
            state.dragState.isScrolling = scrollSpeed !== 0;
        }

        function startAutoScroll() {
            if (state.dragState.timers.scroll) return; // Already running

            const scrollLoop = () => {
                if (!state.dragState.isDragging) {
                    state.dragState.timers.scroll = null;
                    state.dragState.isScrolling = false;
                    return;
                }

                if (state.dragState.currentScrollSpeed !== 0) {
                    window.scrollBy(0, state.dragState.currentScrollSpeed);

                    // Update placeholder position during scroll using the stored touch/mouse position
                    if (state.dragState.element && state.dragState.placeholder) {
                        // Get the current drag element position to simulate the touch point
                        const dragRect = state.dragState.element.getBoundingClientRect();
                        const centerX = dragRect.left + dragRect.width / 2;
                        const centerY = dragRect.top + dragRect.height / 2;

                        // Update placeholder using the drag element's center point
                        updatePlaceholderPosition(centerX, centerY);
                    }
                }

                state.dragState.timers.scroll = requestAnimationFrame(scrollLoop);
            };

            state.dragState.timers.scroll = requestAnimationFrame(scrollLoop);
        }

        function stopAutoScroll() {
            if (state.dragState.timers.scroll) {
                cancelAnimationFrame(state.dragState.timers.scroll);
                state.dragState.timers.scroll = null;
            }
            state.dragState.isScrolling = false;
            state.dragState.currentScrollSpeed = 0;
        }

        function updatePlaceholderPosition(clientX, clientY) {
            const { element, placeholder } = state.dragState;
            if (!element || !placeholder) return;

            element.style.pointerEvents = 'none';
            const elementBelow = document.elementFromPoint(clientX, clientY);
            element.style.pointerEvents = 'auto';

            const targetItem = elementBelow?.closest('.player-item');
            if (targetItem && !targetItem.classList.contains('drag-active') && !targetItem.classList.contains('available-player')) {
                const targetRect = targetItem.getBoundingClientRect();
                const before = clientY < targetRect.top + targetRect.height / 2;
                targetItem.parentNode.insertBefore(placeholder, before ? targetItem : targetItem.nextSibling);
            }
        }

        function endDrag() {
            if (!state.dragState.isDragging) return;

            const { element, placeholder } = state.dragState;

            // Stop auto-scrolling
            stopAutoScroll();

            // Reset delete zone styling
            const deleteZone = $('deleteZone');
            deleteZone.classList.remove('bg-red-800', 'scale-110');
            deleteZone.classList.add('bg-red-600');

            // Remove red pulse from background
            deleteOverlay.classList.remove('active');
            document.body.classList.remove('delete-mode');

            if (element && placeholder) {
                const wasOverDelete = state.dragState.wasOverDelete;

                if (wasOverDelete) {
                    vibrate([100, 50, 100])
                    const playerId = element.dataset.playerId;
                    deletePlayer(playerId);

                    element.remove();
                    placeholder.remove();
                } else {
                    vibrate(100)
                    placeholder.parentNode.replaceChild(element, placeholder);
                    element.classList.remove('drag-active');
                    ['width', 'height', 'left', 'top'].forEach(prop => element.style[prop] = '');
                    updatePlayerOrder();
                }
            }

            Object.assign(state.dragState, {
                element: null,
                placeholder: null,
                isDragging: false,
                wasOverDelete: false
            });
        }

        function deletePlayer(playerId) {
            saveState('delete player');
            const playerIndex = state.players.findIndex(p => p.id === playerId);
            if (playerIndex !== -1) {
                state.players.splice(playerIndex, 1);
                recalculateRanks();
                filterPlayers();
            }
        }

        function cancelDragOperation() {
            clearTimeout(state.dragState.timers.touch);

            stopAutoScroll();

            const deleteZone = $('deleteZone');
            deleteZone.classList.remove('bg-red-800', 'scale-110');
            deleteZone.classList.add('bg-red-600');

            // Remove red pulse from background
            deleteOverlay.classList.remove('active');
            document.body.classList.remove('delete-mode');

            state.dragState.wasOverDelete = false;

            endDrag();
        }

        function handleTouchStart(e) {
            if (state.dragState.isDragging || state.dragState.timers.touch) return;

            const touch = e.touches[0];
            const playerItem = e.target.closest('.player-item');
            if (!playerItem || playerItem.classList.contains('available-player')) return;

            state.dragState.startX = touch.clientX;
            state.dragState.startY = touch.clientY;
            state.dragState.pendingDrag = true;

            state.dragState.timers.touch = setTimeout(() => {
                if (state.dragState.pendingDrag && !state.dragState.isScrolling) {
                    initDrag(playerItem, touch.clientX, touch.clientY);
                    if (navigator.vibrate) navigator.vibrate(50);
                }
            }, cfg.dragDelay);
        }

        function handleTouchMove(e) {
            const touch = e.touches[0];

            if (state.dragState.pendingDrag && !state.dragState.isDragging) {
                const moveX = Math.abs(touch.clientX - state.dragState.startX);
                const moveY = Math.abs(touch.clientY - state.dragState.startY);

                if (moveX > cfg.dragThreshold || moveY > cfg.dragThreshold) {
                    cancelPendingDrag();
                }
                return;
            }

            if (state.dragState.isDragging) {
                e.preventDefault();
                moveDrag(touch.clientX, touch.clientY);
            }
        }
        function handleTouchEnd() {
            cancelPendingDrag();
            endDrag();
        }

        function cancelPendingDrag() {
            state.dragState.pendingDrag = false;
            if (state.dragState.timers.touch) {
                clearTimeout(state.dragState.timers.touch);
                state.dragState.timers.touch = null;
            }
        }

        function handleMouseDown(e) {
            const playerItem = e.target.closest('.player-item');
            if (!playerItem || playerItem.classList.contains('available-player')) return;

            e.preventDefault();
            initDrag(playerItem, e.clientX, e.clientY);
            on(document, 'mousemove', handleMouseMove);
            on(document, 'mouseup', handleMouseUp);
        }

        function handleMouseMove(e) {
            if (!state.dragState.isDragging) return;
            e.preventDefault();
            moveDrag(e.clientX, e.clientY);
        }

        function handleMouseUp() {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            endDrag();
        }

        // Player actions
        window.cycleRisk = id => {
            saveState('change risk');
            const p = state.players.find(x => x.id === id);
            if (p) {
                const i = cfg.risks.indexOf(p.risk);
                p.risk = cfg.risks[(i + 1) % cfg.risks.length];
                filterPlayers();
            }
        };

        window.updateNotes = (id, notes) => {
            const p = state.players.find(x => x.id === id);
            if (p) p.notes = notes;
        };

        window.addPlayer = addPlayer;

        window.deletePlayer = deletePlayer;

        window.openNotesModal = openNotesModal;

        window.draftPlayer = id => {
            saveState('draft player');
            const i = state.players.findIndex(p => p.id === id);
            if (i !== -1) {
                state.draftedPlayers.unshift(state.players.splice(i, 1)[0]);
                filterPlayers();
                renderRecentlyDrafted();
            }
        };

        window.undraftPlayer = id => {
            saveState('undraft player');
            const i = state.draftedPlayers.findIndex(p => p.id === id);
            if (i !== -1) {
                state.players.push(state.draftedPlayers.splice(i, 1)[0]);
                state.players.sort((a, b) => a.overallRank - b.overallRank);
                filterPlayers();
                renderRecentlyDrafted();
            }
        };

        function toggleDraftMode() {
            // Check if position filter is active
            if (state.positionFilter !== 'ALL' && !state.isDraftMode) {
                alert('Please switch to "All Positions" view to enter draft mode');
                return;
            }

            // Add warning when exiting draft mode (but not when entering)
            if (state.isDraftMode && state.draftedPlayers.length > 0) {
                const confirmExit = confirm('Are you sure you want to exit draft mode? Drafted players will be moved back to your rankings.');
                if (!confirmExit) {
                    return; // Don't exit if user cancels
                }

                state.players.push(...state.draftedPlayers);
                state.draftedPlayers = [];
                state.players.sort((a, b) => a.overallRank - b.overallRank);
            }

            state.isDraftMode = !state.isDraftMode;
            $('recentlyDraftedSection').classList.toggle('hidden');

            filterPlayers();
            if (state.isDraftMode) renderRecentlyDrafted();
        }

        // File operations
        function loadRankings(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.players && !data.rankerName) {
                        state.players = data.players.map((p, i) => ({
                            ...p,
                            id: p.id || `p${i}`,
                            risk: p.risk || 'Medium',
                            notes: p.notes || '',
                            overallRank: i + 1
                        }));
                        recalculateRanks();
                    } else {
                        Object.assign(state, {
                            players: data.players || [],
                            draftedPlayers: data.draftedPlayers || []
                        });
                        $('rankerName').value = data.rankerName || '';
                        $('scoringFormat').value = data.scoringFormat || 'PPR';
                    }

                    // Reset position filter to ALL when loading
                    state.positionFilter = 'ALL';
                    updatePositionFilterButton();

                    // Clear history when loading new data
                    state.history.undoStack = [];
                    state.history.redoStack = [];
                    updateUndoRedoButtons();

                    filterPlayers();
                    if (state.isDraftMode) renderRecentlyDrafted();
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function saveRankings() {
            const data = {
                rankerName: $('rankerName').value.trim(),
                year: cfg.year,
                scoringFormat: $('scoringFormat').value,
                players: state.players,
                draftedPlayers: state.draftedPlayers
            };

            let name = data.rankerName || 'Your';
            // Add 's' if name doesn't already end with 's' (case-insensitive)
            if (!name.toLowerCase().endsWith('s') && name.toLowerCase() !== 'your') {
                name += 's';
            }

            const backendFormat = cfg.fileMap[data.scoringFormat].replace('.json', '') || 'PPR';
            downloadFile(JSON.stringify(data, null, 2), `${name}${cfg.year}${backendFormat}Rankings.json`, 'application/json');
        }

        function downloadPrintable() {
            let name = $('rankerName').value.trim() || 'Your';
            // Add 's' if name doesn't already end with 's' (case-insensitive)
            if (!name.toLowerCase().endsWith('s') && name.toLowerCase() !== 'your') {
                name += 's';
            }

            const scoring = $('scoringFormat').value || 'PPR';
            const backendFormat = cfg.fileMap[scoring].replace('.json', '');

            downloadFile(generatePrintableHTML(), `${name}${cfg.year}${backendFormat}Printable.html`, 'text/html');
        }

        function downloadFile(content, filename, type) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([content], { type }));
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // Printable generation
        function generatePrintableHTML() {
            // Handle possessive correctly
            const rankerName = $('rankerName').value.trim() || 'Your';
            let possessiveName;
            if (rankerName.toLowerCase() === 'your') {
                possessiveName = rankerName; // No possessive for "Your"
            } else if (rankerName.toLowerCase().endsWith('s')) {
                possessiveName = rankerName + "'";
            } else {
                possessiveName = rankerName + "'s";
            }

            const title = `${possessiveName} ${cfg.year} ${$('scoringFormat').value} Rankings`;
            const perCol = 30, perPage = 60;

            const genPlayer = p => {
                const [first, ...last] = p.name.split(/\s+/);
                const riskClass = p.risk ? `risk-${p.risk.toLowerCase()}` : '';
                return `<div class="player ${riskClass}">
                        <div class="rank">${p.overallRank}</div>
                        <div class="position ${p.position}">${p.position}${p.positionRank}</div>
                        <div class="player-info">
                            <div class="name"><div class="first-name">${first}</div><div class="last-name">${last.join(' ')}</div></div>
                            <div class="team-adp">
                                <span class="team">${p.team}</span>
                                ${p.adp ? `<span class="adp">ADP: ${p.adp}</span>` : ''}
                            </div>
                        </div>
                        <div class="notes">${p.notes || ''}</div>
                    </div>`;
            };

            const genColumn = players => players.map(genPlayer).join('');

            const pages = [];
            for (let i = 0; i < state.players.length; i += perPage) {
                const pageNum = Math.floor(i / perPage) + 1;
                pages.push(`<div class="page">
                        <div class="header">
                            <div class="subtitle">${title} - Generated on ${new Date().toLocaleDateString()}</div>
                            <div class="url-header">${window.location.origin}</div>
                        </div>
                        <div class="columns">
                            <div class="column">${genColumn(state.players.slice(i, i + perCol))}</div>
                            <div class="column">${genColumn(state.players.slice(i + perCol, i + perPage))}</div>
                        </div>
                        <div class="page-footer">
                            <span>${window.location.hostname}</span>
                            <span>Page ${pageNum} of ${Math.ceil(state.players.length / perPage)}</span>
                        </div>
                    </div>`);
            }

            const styles = `
*{margin:0;padding:0;box-sizing:border-box}body{font:10px/1.1 Arial,sans-serif;color:#333;background:#fff}
.page{width:8.5in;height:11in;margin:0 auto;padding:.2in;page-break-after:always;position:relative;display:flex;flex-direction:column}
.page:last-child{page-break-after:avoid}.header{text-align:center;margin-bottom:.1in;padding-bottom:3px;display:flex;justify-content:space-between;align-items:center}
.url-header{font-size:9px;color:#666}.subtitle{font-size:10px;color:#666;flex-grow:1}
.columns{display:flex;gap:.1in;flex-grow:1}.column{width:3.85in}
.player{position:relative;margin-bottom:2px;height:28px;width:3.85in;border-radius:2px;border-left:3px solid #d1d5db}
.player.risk-high{border-left:3px solid #dc2626}
.player.risk-medium{border-left:3px solid #d97706}
.player.risk-low{border-left:3px solid #16a34a}
.rank{position:absolute;left:4px;top:6px;width:18px;height:16px;font:bold 11px/16px Arial;color:#111;text-align:center}
.position{position:absolute;left:25px;top:6px;width:28px;height:16px;font:bold 7px/16px Arial;text-align:center;color:#000}
.player-info{position:absolute;left:56px;top:2px;width:85px;height:24px;overflow:hidden}
.name{font:bold 8px/9px Arial}.first-name,.last-name{display:block;height:9px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.team-adp{font-size:6px;height:7px;line-height:7px;display:flex;justify-content:space-between}
.team{color:#666}.adp{color:#888}
.notes{position:absolute;left:144px;top:2px;width:2.25in;height:24px;background:#fff;border:1px solid #d1d5db;
border-radius:2px;padding:2px 3px;font-size:6px;color:#374151;word-wrap:break-word;overflow:hidden;line-height:7px}
.page-footer{position:absolute;bottom:.1in;left:.2in;right:.2in;display:flex;justify-content:space-between;font-size:9px;color:#666}
@media print{body{margin:0}.page{margin:0;page-break-after:always}.page:last-child{page-break-after:avoid}}`;
            return `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>${title}</title><style>${styles}</style></head><body>${pages.join('')}</body></html>`;
        }
    </script>
    <footer class="bg-slate-800 border-t border-slate-700">
        <div class="container mx-auto px-4 py-6 max-w-6xl">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                <div class="text-center md:text-left">
                    <div class="text-gray-100 font-semibold">Draft Craft</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-400 text-sm">Made in the lab</div>
                    <div class="text-gray-400 text-sm">The...</div>
                    <div class="text-gray-400 text-sm">Squelab?</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs mt-1">
                        © 2025 drftcrft.com
                    </div>
                </div>
            </div>
        </div>
    </footer>
</body>
</html>